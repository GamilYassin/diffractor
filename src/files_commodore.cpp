#include "pch.h"

#include "files.h"

struct media_entry
{
	//bool available = false;
	uint8_t next_track = 0;
	uint8_t next_sector = 0;
	uint8_t file_type;
	uint8_t start_track = 0;
	uint8_t start_sector = 0;
	std::vector<uint8_t> pet_name;
	uint32_t adress_start = 0;
	uint32_t adress_end = 0;
	uint8_t sectors = 0;
	uint32_t file_size = 0;
};

struct d64_media
{
	//std::u8string FILE_TYPE[0x100];
	std::u8string filename;
	std::u8string diskname;
	std::vector<media_entry> entries;
};


//static uint32_t PRIMARY_G0[]{
//	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
//		0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
//		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
//		0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
//		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
//		0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
//		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
//		0x0058, 0x0059, 0x005A, 0x005B, 0x00A3, 0x005D, 0x2191, 0x2190,
//		0x2500, 0x2660, 0x1FB72, 0x1FB78, 0x1FB77, 0x1FB76, 0x1FB7A, 0x1FB71,
//		0x1FB74, 0x256E, 0x2570, 0x256F, 0x1FB7C, 0x2572, 0x2571, 0x1FB7D,
//		0x1FB7E, 0x2022, 0x1FB7B, 0x2665, 0x1FB70, 0x256D, 0x2573, 0x25CB,
//		0x2663, 0x1FB75, 0x2666, 0x253C, 0x1FB8C, 0x2502, 0x03C0, 0x25E5,
//};
//
//static uint32_t PRIMARY_G1[]{
//	0x00A0, 0x258C, 0x2584, 0x2594, 0x2581, 0x258F, 0x2592, 0x2595,
//		0x1FB8F, 0x25E4, 0x1FB87, 0x251C, 0x2597, 0x2514, 0x2510, 0x2582,
//		0x250C, 0x2534, 0x252C, 0x2524, 0x258E, 0x258D, 0x1FB88, 0x1FB82,
//		0x1FB83, 0x2583, 0x1FB7F, 0x2596, 0x259D, 0x2518, 0x2598, 0x259A,
//		0x2500, 0x2660, 0x1FB72, 0x1FB78, 0x1FB77, 0x1FB76, 0x1FB7A, 0x1FB71,
//		0x1FB74, 0x256E, 0x2570, 0x256F, 0x1FB7C, 0x2572, 0x2571, 0x1FB7D,
//		0x1FB7E, 0x2022, 0x1FB7B, 0x2665, 0x1FB70, 0x256D, 0x2573, 0x25CB,
//		0x2663, 0x1FB75, 0x2666, 0x253C, 0x1FB8C, 0x2502, 0x03C0, 0x25E5,
//		0x00A0, 0x258C, 0x2584, 0x2594, 0x2581, 0x258F, 0x2592, 0x2595,
//		0x1FB8F, 0x25E4, 0x1FB87, 0x251C, 0x2597, 0x2514, 0x2510, 0x2582,
//		0x250C, 0x2534, 0x252C, 0x2524, 0x258E, 0x258D, 0x1FB88, 0x1FB82,
//		0x1FB83, 0x2583, 0x1FB7F, 0x2596, 0x259D, 0x2518, 0x2598, 0x259A,
//};
//
//static uint32_t ALTERNATE_G0[]{
//	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
//		0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
//		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
//		0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
//		0x0040, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
//		0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
//		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
//		0x0078, 0x0079, 0x007A, 0x005B, 0x00A3, 0x005D, 0x2191, 0x2190,
//		0x2500, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
//		0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
//		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
//		0x0058, 0x0059, 0x005A, 0x253C, 0x1FB8C, 0x2502, 0x1FB96, 0x1FB98,
//};
//
//static uint32_t ALTERNATE_G1[]{
//	0x00A0, 0x258C, 0x2584, 0x2594, 0x2581, 0x258F, 0x2592, 0x2595,  // a0
//		0x1FB8F, 0x1FB99, 0x1FB87, 0x251C, 0x2597, 0x2514, 0x2510, 0x2582, // a8
//		0x250C, 0x2534, 0x252C, 0x2524, 0x258E, 0x258D, 0x1FB88, 0x1FB82, // b0
//		0x1FB83, 0x2583, 0x2713, 0x2596, 0x259D, 0x2518, 0x2598, 0x259A, // b8
//		0x2500, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // c0
//		0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // c8
//		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // d0
//		0x0058, 0x0059, 0x005A, 0x253C, 0x1FB8C, 0x2502, 0x1FB96, 0x1FB98, // d8
//		0x00A0, 0x258C, 0x2584, 0x2594, 0x2581, 0x258F, 0x2592, 0x2595,  // e0
//		0x1FB8F, 0x1FB99, 0x1FB87, 0x251C, 0x2597, 0x2514, 0x2510, 0x2582, // e8
//		0x250C, 0x2534, 0x252C, 0x2524, 0x258E, 0x258D, 0x1FB88, 0x1FB82, // f0
//		0x1FB83, 0x2583, 0x2713, 0x2596, 0x259D, 0x2518, 0x2598, 0x259A, // f8
//};

// font: https://style64.org/petscii/
// mapping table: https://github.com/euphoriabbs/qodem/blob/master/source/petscii.c#L83C1-L120C3

static wchar_t c64_uppercase_normal_chars[] = {
	/* Non-printable C0 set */
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	/* Private use area matching C64 Pro Mono STYLE font */
	0x0020, 0xE021, 0xE022, 0xE023, 0xE024, 0xE025, 0xE026, 0xE027,
	0xE028, 0xE029, 0xE02A, 0xE02B, 0xE02C, 0xE02D, 0xE02E, 0xE02F,
	0xE030, 0xE031, 0xE032, 0xE033, 0xE034, 0xE035, 0xE036, 0xE037,
	0xE038, 0xE039, 0xE03A, 0xE03B, 0xE03C, 0xE03D, 0xE03E, 0xE03F,
	0xE040, 0xE041, 0xE042, 0xE043, 0xE044, 0xE045, 0xE046, 0xE047,
	0xE048, 0xE049, 0xE04A, 0xE04B, 0xE04C, 0xE04D, 0xE04E, 0xE04F,
	0xE050, 0xE051, 0xE052, 0xE053, 0xE054, 0xE055, 0xE056, 0xE057,
	0xE058, 0xE059, 0xE05A, 0xE05B, 0xE05C, 0xE05D, 0xE05E, 0xE05F,
	0xE060, 0xE061, 0xE062, 0xE063, 0xE064, 0xE065, 0xE066, 0xE067,
	0xE068, 0xE069, 0xE06A, 0xE06B, 0xE06C, 0xE06D, 0xE06E, 0xE06F,
	0xE070, 0xE071, 0xE072, 0xE073, 0xE074, 0xE075, 0xE076, 0xE077,
	0xE078, 0xE079, 0xE07A, 0xE07B, 0xE07C, 0xE07D, 0xE07E, 0xE07F,
	/* Non-printable C1 set */
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	/* Private use area matching C64 Pro Mono STYLE font */
	0x0020, 0xE0A1, 0xE0A2, 0xE0A3, 0xE0A4, 0xE0A5, 0xE0A6, 0xE0A7,
	0xE0A8, 0xE0A9, 0xE0AA, 0xE0AB, 0xE0AC, 0xE0AD, 0xE0AE, 0xE0AF,
	0xE0B0, 0xE0B1, 0xE0B2, 0xE0B3, 0xE0B4, 0xE0B5, 0xE0B6, 0xE0B7,
	0xE0B8, 0xE0B9, 0xE0BA, 0xE0BB, 0xE0BC, 0xE0BD, 0xE0BE, 0xE0BF,
	0xE0C0, 0xE0C1, 0xE0C2, 0xE0C3, 0xE0C4, 0xE0C5, 0xE0C6, 0xE0C7,
	0xE0C8, 0xE0C9, 0xE0CA, 0xE0CB, 0xE0CC, 0xE0CD, 0xE0CE, 0xE0CF,
	0xE0D0, 0xE0D1, 0xE0D2, 0xE0D3, 0xE0D4, 0xE0D5, 0xE0D6, 0xE0D7,
	0xE0D8, 0xE0D9, 0xE0DA, 0xE0DB, 0xE0DC, 0xE0DD, 0xE0DE, 0xE0DF,
	0xE0E0, 0xE0E1, 0xE0E2, 0xE0E3, 0xE0E4, 0xE0E5, 0xE0E6, 0xE0E7,
	0xE0E8, 0xE0E9, 0xE0EA, 0xE0EB, 0xE0EC, 0xE0ED, 0xE0EE, 0xE0EF,
	0xE0F0, 0xE0F1, 0xE0F2, 0xE0F3, 0xE0F4, 0xE0F5, 0xE0F6, 0xE0F7,
	0xE0F8, 0xE0F9, 0xE0FA, 0xE0FB, 0xE0FC, 0xE0FD, 0xE0FE, 0xE0FF
};

static uint32_t to_unicode(const uint32_t cp, const bool alt)
{
	//if (alt && cp >= 0x20 && cp <= 0x7F) return ALTERNATE_G0[cp - 0x20];
	//if (alt && cp >= 0xA0 && cp <= 0xFF) return ALTERNATE_G1[cp - 0xA0];
	//if (cp >= 0x20 && cp <= 0x7F) return PRIMARY_G0[cp - 0x20];
	//if (cp >= 0xA0 && cp <= 0xFF) return PRIMARY_G1[cp - 0xA0];

	auto c = c64_uppercase_normal_chars[cp & 0xff];
	if (c == 0) return ' ';
	return c; //return cp;
}

static std::vector<files::d64_item> dir_list(const d64_media& disk)
{
	//	23 chars?
	/*std::vector<uint8_t> list{
		0x1f, 0x08, 0x00,
		0x00, 0x12, 0x22, 0x41, 0x53, 0x53, 0x20, 0x50, 0x52, 0x45, 0x53, 0x45, 0x4e, 0x54, 0x53, 0x3a, 0x20, 0x20, 0x20, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		0x3f, 0x08,
		0xc2, 0x00, 0x20, 0x22, 0x49, 0x4e, 0x54, 0x45, 0x54, 0x4e, 0x41, 0x54, 0x2e, 0x20, 0x4b, 0x41, 0x52, 0x41, 0x54, 0x45, 0x22, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x20, 0x20, 0x00,
		0x5f, 0x08,
		0x01, 0x00, 0x20, 0x20, 0x20, 0x22, 0x49, 0x2e, 0x4b, 0x41, 0x52, 0x41, 0x54, 0x45, 0x20, 0x2d, 0x48, 0x49, 0x2f, 0x52, 0x45, 0x4d, 0x22, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x00,
		0x7f, 0x08,
		0x00, 0x00, 0x20, 0x20, 0x20, 0x22, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x22, 0x20, 0x44, 0x45, 0x4c, 0x20, 0x20, 0x00,
		0x9f, 0x08,
		0x71, 0x00, 0x20, 0x22, 0x49, 0x4e, 0x54, 0x2e, 0x20, 0x4b, 0x41, 0x52, 0x41, 0x54, 0x45, 0x2b, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x20, 0x20, 0x00,
		0xbf, 0x08,
		0x2f, 0x00, 0x20, 0x20, 0x22, 0x30, 0x31, 0x2e, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x20, 0x00,
		0xdf, 0x08,
		0x2b, 0x00, 0x20, 0x20, 0x22, 0x30, 0x32, 0x2e, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x20, 0x00,
		0xff, 0x08,
		0x01, 0x00, 0x20, 0x20, 0x20, 0x22, 0x49, 0x4e, 0x54, 0x2e, 0x20, 0x4b, 0x41, 0x52, 0x41, 0x54, 0x45, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x22, 0x20, 0x50, 0x52, 0x47, 0x20, 0x20, 0x00,
		0x1d,
		//	265 BLOCKS FREE.
		0x09, 0x09, 0x01, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x53, 0x20, 0x46, 0x52, 0x45, 0x45, 0x2e, 0x20,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00
	};*/

	//uint8_t lc = 0x1f;
	//uint8_t lh = 0x08;

	std::vector<files::d64_item> result;
	//std::vector<uint8_t> line
	//{
	//	0x1f, 0x08, 0x00
	//};
	//line.push_back(0x00); //	HEADLINE 0
	//line.push_back(0x12); //	HEADLINE BOLD ?
	//line.push_back(0x22); //	"

	//for (const auto i : disk.diskname)
	//{
	//	line.emplace_back(i);
	//}
	//line.push_back(0x22); //	"
	//for (auto j = 0u; j < 24u - disk.diskname.size() - 2u; j++)
	//{
	//	line.push_back(0x20); //	FILLING SPACES
	//}

	//result.emplace_back(std::move(line));
	//line.clear();

	for (const auto& entry : disk.entries)
	{
		if (entry.file_type != 0)
		{
			std::vector<uint32_t> line;
			//if ((lc + 0x20) > 0xff)
			//	lh++;
			//lc += 0x20;
			//line.push_back(lc); //	Line separation
			//line.push_back(lh); //	Line separation
			//line.push_back(static_cast<uint8_t>(entry.sector_size)); //	SIZE
			//line.push_back(0x00);

			for (const auto c : str::to_string(entry.file_size))
			{
				line.emplace_back(c);
			}

			while (line.size() < 4) line.emplace_back(' ');
			line.emplace_back('\"');
			//line.push_back(0x22); //	"

			for (const auto c : entry.pet_name)
			{
				line.emplace_back(to_unicode(c, false));
			}

			line.emplace_back('\"');
			//line.emplace_back(0x256e);
			while (line.size() < 23) line.emplace_back(' ');

			//for (const char8_t j : entry.pet_name)
			//{
			//	line.push_back(j); //	NAME
			//}
			//line.push_back(0x22); //	"
			//line.push_back(0x20); //	SPACE

			std::u8string file_type;

			if (entry.file_type == 0x80) file_type = u8"DEL"sv;
			if (entry.file_type == 0x81) file_type = u8"SEQ"sv;
			if (entry.file_type == 0x82) file_type = u8"PRG"sv;
			if (entry.file_type == 0x83) file_type = u8"USR"sv;
			if (entry.file_type == 0x84) file_type = u8"REL"sv;
			if (entry.file_type == 0x99) file_type = u8"CRT"sv;

			for (const auto c : file_type)
			{
				line.emplace_back(c);
			}
			//for (const char8_t j : entry.file_type)
			//{
			//	line.push_back(j); //	FILE_EXT
			//}
			//for (auto j = 0u; j < 26u - entry.pet_name.size() - 5u - (4u - f.size()); j++)
			//{
			//	line.push_back(0x20); //	FILLING SPACES
			//}

			std::u8string line2;
			auto inserter = std::back_inserter(line2);
			for (const uint32_t c : line)
			{
				str::char32_to_utf8(inserter, c);
			}


			result.emplace_back(line2);
		}
	}

	return result;
}

static d64_media parse_disk(const uint8_t* const data, const size_t data_len)
{
	const auto is_d64 = data_len == 0x002ab00;
	const auto is_d81 = data_len == 0x00c8000;

	const int SECTOR_SIZE = 256;
	const int DIR_TRACK = is_d64 ? 18 : 40;
	const int DIR_SECTOR = is_d64 ? 1 : 3;
	const int DIR_ENTRY_SIZE = 32;
	const int SECTORS_PER_TRACK = is_d64 ? 21 : 40;

	d64_media disk;

	int next_track = DIR_TRACK;
	int next_sector = DIR_SECTOR;

	while (next_track != 0)
	{
		const auto dir_sector_offset = ((next_track - 1) * SECTORS_PER_TRACK + next_sector) * SECTOR_SIZE;

		if (dir_sector_offset + SECTOR_SIZE > data_len)
			break;

		for (int i = 0; i < SECTOR_SIZE; i += DIR_ENTRY_SIZE)
		{
			const auto dir_entry = dir_sector_offset + i;
			uint8_t file_type = data[dir_entry + 2];

			if (file_type != 0)
			{
				media_entry entry;
				entry.file_type = file_type;
				entry.file_size = data[dir_entry + 30] + (data[dir_entry + 31] << 8);
				entry.pet_name.assign(data + dir_entry + 5, data + dir_entry + 5 + 16);
				disk.entries.emplace_back(entry);
			}
		}
		next_track = data[dir_sector_offset];
		next_sector = data[dir_sector_offset + 1];
	}

	return disk;
}

#pragma pack(push, 1)

struct t64_header
{
	uint8_t signature[32];
	uint16_t version;
	uint16_t used_entries;
	uint16_t total_entries;
	uint8_t reserved[26];
};

struct t64_file_entry {
	uint8_t type;
	uint8_t type_1541;
	uint16_t start_address;
	uint16_t end_address;
	uint16_t reserved1;
	uint32_t offset;
	uint32_t reserved2;
	uint8_t file_name[16];
};

struct crt_header {
	uint8_t signature[16];
	uint32_t header_length;
	uint16_t version;
	uint16_t cartridge_type;
	uint8_t port_exrom;
	uint8_t port_game;
	uint8_t reserved[6];
	uint8_t name[32];
};

struct crt_chip_header {
	uint8_t signature[4];
	uint32_t chip_packet_length;
	uint16_t chip_type;
	uint16_t bank_number;
	uint16_t load_address;
	uint16_t rom_image_size;
};

#pragma pack(pop)

d64_media parse_t64(const uint8_t* const data, const size_t data_len)
{
	d64_media result;
	const auto header = reinterpret_cast<const t64_header*>(data);

	for (uint16_t i = 0; i < header->used_entries; ++i)
	{
		const auto dir_offset = sizeof(t64_header) + i * sizeof(t64_file_entry);

		if (dir_offset + sizeof(t64_file_entry) > data_len)
			break;

		const auto file = reinterpret_cast<const t64_file_entry*>(data + dir_offset);
		media_entry entry;
		entry.file_type = file->type_1541;
		entry.pet_name.assign(file->file_name, file->file_name + 16);
		result.entries.push_back(entry);
	}

	return result;
}

d64_media parse_crt(const uint8_t* const data, const size_t data_len)
{
	const auto header = reinterpret_cast<const crt_header*>(data);

	d64_media result;
	size_t offset = sizeof(crt_header);

	while (offset < data_len)
	{
		if (data_len - offset < sizeof(crt_chip_header)) {
			break;
		}

		const auto chipHeader = reinterpret_cast<const crt_chip_header*>(data + offset);
		if (std::memcmp(chipHeader->signature, "CHIP", 4) != 0) {
			break;
		}

		media_entry entry;
		entry.file_type = 0x99;
		entry.pet_name.assign(header->name, header->name + 32);
		result.entries.push_back(entry);

		offset += sizeof(crt_chip_header) + chipHeader->rom_image_size;
	}

	return result;
}


std::vector<files::d64_item> files::list_disk(const df::blob& selected_item_data)
{
	const auto is_d64 = selected_item_data.size() == 0x002ab00;
	const auto is_d81 = selected_item_data.size() == 0x00c8000;

	d64_media media;

	if (selected_item_data.size() > 32 &&
		std::memcmp(selected_item_data.data(), "C64 tape image file", 19) == 0)
	{
		media = parse_t64(selected_item_data.data(), selected_item_data.size());
	}
	else if (selected_item_data.size() > 16 &&
		std::memcmp(selected_item_data.data(), "C64 CARTRIDGE   ", 16) == 0)
	{
		media = parse_crt(selected_item_data.data(), selected_item_data.size());
	}
	else if (is_d64 || is_d81)
	{
		media = parse_disk(selected_item_data.data(), selected_item_data.size());
	}

	return dir_list(media);
}
